class Design < ApplicationRecord

  TAG_SEPARATORS = {
      'astek.com': '__',
      'astekhome.com': '__',
      'onairdesign.com': ':'
  }

  resourcify

  # include RankedModel
  # ranks :row_order, with_same: :collection_id

  acts_as_paranoid

  include Websiteable

  include Descriptionable

  acts_as_taggable_on :keywords

  include KeywordValidateable

  scope :available, -> { where('expires_on IS NULL OR expires_on >= NOW()') }
  scope :unsubcollected, -> { where('subcollection_id IS NULL') }
  scope :digital, -> {
    unscope(:order)
        .joins(variants: :variant_type)
        .joins(collection: :product_category)
        .where({ 'product_categories.name': %w[Digital] })
        .available.order('variants.sku ASC')
  }
  scope :distributed, -> {
    unscope(:order)
        .joins({ variants: :variant_type }, { collection: :product_category })
        .where({ 'product_categories.name': ['Contract Vinyl', 'Naturals', 'Residential'] })
        .available.order('variants.sku ASC')
  }
  default_scope { order(sku: :asc) }

  belongs_to :collection, inverse_of: :designs
  # belongs_to :sale_unit, inverse_of: :designs
  belongs_to :vendor, inverse_of: :designs
  belongs_to :country_of_origin, class_name: 'Country', foreign_key: 'country_id', optional: true
  belongs_to :subcollection, inverse_of: :designs, optional: true

  has_many :variants, -> { order(row_order: :asc) }, dependent: :destroy

  has_many :design_images, -> { order(row_order: :asc) }, foreign_key: 'owner_id', dependent: :destroy

  has_many :design_properties, -> { order(row_order: :asc) }, dependent: :destroy, inverse_of: :design
  has_many :properties, through: :design_properties

  has_many :design_aliases, dependent: :destroy

  has_and_belongs_to_many :styles

  # Custom materials should really be associated with Colorways (variants),
  # but the website only displays material options by design
  has_many :custom_materials, dependent: :destroy, inverse_of: :design
  has_many :substrates, through: :custom_materials

  validates :name, presence: true
  validates :sku, uniqueness:true, presence: true

  accepts_nested_attributes_for :design_properties, allow_destroy: true, reject_if: lambda { |pp| pp[:property_name].blank? }

  def variants_for_domain domain
    self.variants.for_domain domain
  end

  def install_images_for_domain domain
    self.variants_for_domain(domain).map { |v| v.install_images_for_domain(domain).first.nil? ? nil : { variant_id: v.id, install_image: v.install_images_for_domain(domain).first } }.compact
  end

  def description_for_domain domain
    if self.descriptions.for_domain(domain).any?
      self.descriptions.for_domain(domain).first.description
    end
  end

  def property name
    self.design_properties.joins(:property).find_by(properties: { name: name }).try(:value)
  end

  def set_property name, value
      property = Property.find_by(name: name)
      design_property = DesignProperty.where(design: self, property: property).first_or_initialize
      design_property.value = value
      design_property.save!
  end

  def delete_property name
    if dp = self.design_properties.joins(:property).find_by(properties: { name: name })
      dp.destroy
    end
  end

  def set_custom_material substrate
    CustomMaterial.find_or_create_by!(design: self, substrate: substrate, default_material: substrate.name == 'Paper')
  end

  def delete_custom_material substrate
    if cm = CustomMaterial.find_by(design: self, substrate: substrate)
      cm.destroy
    end
  end

  def available?
    self.expires_on.nil? || self.expires_on > Time.now
  end

  def digital?
    %w[Digital].include? self.collection.product_category.name
  end

  def distributed?
    ['Contract Vinyl', 'Naturals', 'Residential'].include? self.collection.product_category.name
  end

  def has_colorways?
    self.variants.map { |v| v.variant_type.name }.include? 'Color Way'
  end

  def peel_and_stick_version
    if self.digital?
      sku = 'PS' + self.sku
      Design.find_by(sku: sku)
    end
  end

  # For Shopify
  # If product has an actual name (as opposed to just a SKU for its name),
  # include it for SEO purposes, and prepend "d" (for "design") to the SKU
  # to ensure that this is distinct from handles generated by other methods
  def handle
    if self.name == self.sku
      'd-' + self.sku.parameterize
    else
      if self.collection.prepend_collection_name_to_design_names
        self.collection.name.parameterize + '-' + self.name.parameterize + '-d-' + self.sku.parameterize
      elsif self.collection.append_collection_name_to_design_names
        self.name.parameterize + '-' + self.collection.name.parameterize + '-d-' + self.sku.parameterize
      else
        self.name.parameterize + '-d-' + self.sku.parameterize
      end
    end
  end

  def tags domain

    separator = tag_separator domain
    
    # Designs which should not show up in search results should have only the
    # tag "legacy__SKU" assigned to them. This will tell the Shopify system not
    # to display them except within their collections.
    if self.suppress_from_searches
      tags = ["legacy#{separator}SKU"]
    else
      tags = []

      tags += to_tags('style', self.styles.map { |s| s.name }, separator)
      tags += to_tags('type', self.variants.map { |v| v.product_types.select { |t| t.websites.map { |w| w.domain }.include?(domain) }.map { |t| t.name.parameterize } }.flatten.uniq, separator)

      if domain == 'astek.com'
        if self.digital?
          tags += %w[feature__digital feature__scale feature__design feature__material feature__color]
        else
          tags += %w[feature__instock feature__return-policy feature__pricing]
          tags << "feature__lead-time-#{self.collection.lead_time.name.parameterize}" if self.collection.lead_time
        end
      end

      if all_keywords = self.merged_keywords
        tags += to_tags('keyword', all_keywords, separator)
      end

      tags += to_tags('color', self.variants.map { |v| v.colors.map { |c| c.name } }.flatten.uniq, separator)
    end

    if domain == 'astekhome.com'

      if self.digital?
        if self.material_tags separator
          tags += self.material_tags separator
        end
      end

      # if self.exists_in_peel_and_stick_version?
      #   tags <<
      # end
    end

    tags.join(', ')

  end

  def tag_separator domain
    TAG_SEPARATORS[domain.to_sym]
  end

  def to_tags(name, values, separator)
    tags = []
    values.each do |value|
      tags << to_tag(name, value, separator)
    end
    tags
  end

  def to_tag(name, value, separator = '__')
    "#{name}#{separator}#{value.strip}"
  end

  def merged_keywords
    (self.collection.keyword_list + self.keyword_list).uniq
  end

  # def merged_keywords
  #   collection_keywords = []
  #   design_keywords = []
  #
  #   if self.collection.keywords
  #     collection_keywords = self.collection.keywords.split(',').map { |k| k.strip }.reject { |k| k.empty? }
  #   end
  #
  #   if self.keywords
  #     design_keywords = self.keywords.split(',').map { |k| k.strip }.reject { |k| k.empty? }
  #   end
  #
  #   (collection_keywords + design_keywords).uniq
  # end

  def material_tags separator
    if self.custom_materials.any?
      material_tags = []
      self.custom_materials.each do |m|
        material_tags << to_tag('material', m.name.parameterize, separator)
      end
      material_tags
    end
  end

  class << self
    def next_available_sku prefix
      last = last_sku prefix
      last_number = /^#{prefix.prefix}#{prefix.separator}(\d+)$/.match(last)[1].to_i
      next_number = last_number + 1
      "#{prefix.prefix}#{prefix.separator}#{next_number}"
    end

    def last_sku prefix
      prefix_string = prefix.prefix + prefix.separator
      sql = "SELECT
        MAX(D.sku) AS last_sku
      FROM
        designs D
        INNER JOIN collections C ON D.collection_id = C.id
      WHERE
        C.product_category_id IN(1,4)
        AND D.sku LIKE '#{prefix_string}%'"
      res = ActiveRecord::Base.connection.exec_query(sql)
      res[0]['last_sku']
    end
  end

end
